"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createUpgradeReport = exports.createVulnerabilityReport = exports.createLicenseReport = exports.createComponentVulnerabilityReports = exports.createComponentLicenseReports = exports.createComponentReport = exports.createRapidScanReport = exports.createRapidScanReportString = exports.TABLE_HEADER = void 0;
var blackduck_api_1 = require("./blackduck-api");
var SIGLogger_1 = require("../SIGLogger");
exports.TABLE_HEADER = '| Policies Violated | Dependency | License(s) | Vulnerabilities | Short Term Recommended Upgrade | Long Term Recommended Upgrade |\r\n' + '|-|-|-|-|-|-|\r\n';
function createRapidScanReportString(blackduck_url, blackduck_api_token, policyViolations, policyCheckWillFail) {
    return __awaiter(this, void 0, void 0, function () {
        var message, violationSymbol, componentReports, tableBody, reportTable;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    message = '';
                    if (!(policyViolations.length == 0)) return [3 /*break*/, 1];
                    message = message.concat('# :white_check_mark: None of your dependencies violate policy!');
                    return [3 /*break*/, 3];
                case 1:
                    violationSymbol = policyCheckWillFail ? ':x:' : ':warning:';
                    message = message.concat("# ".concat(violationSymbol, " Found dependencies violating policy!\r\n\r\n"));
                    return [4 /*yield*/, createRapidScanReport(blackduck_url, blackduck_api_token, policyViolations)];
                case 2:
                    componentReports = _a.sent();
                    tableBody = componentReports.map(function (componentReport) { return createComponentRow(componentReport); }).join('\r\n');
                    reportTable = exports.TABLE_HEADER.concat(tableBody);
                    message = message.concat(reportTable);
                    _a.label = 3;
                case 3: return [2 /*return*/, message];
            }
        });
    });
}
exports.createRapidScanReportString = createRapidScanReportString;
function createComponentRow(component) {
    var violatedPolicies = component.violatedPolicies.join('<br/>');
    var componentInViolation = (component === null || component === void 0 ? void 0 : component.href) ? "[".concat(component.name, "](").concat(component.href, ")") : component.name;
    var componentLicenses = component.licenses.map(function (license) { return "".concat(license.violatesPolicy ? ':x: &nbsp; ' : '', "[").concat(license.name, "](").concat(license.href, ")"); }).join('<br/>');
    var vulnerabilities = component.vulnerabilities.map(function (vulnerability) { return "".concat(vulnerability.violatesPolicy ? ':x: &nbsp; ' : '', "[").concat(vulnerability.name, "](").concat(vulnerability.href, ")").concat(vulnerability.cvssScore && vulnerability.severity ? " ".concat(vulnerability.severity, ": CVSS ").concat(vulnerability.cvssScore) : ''); }).join('<br/>');
    var shortTermString = component.shortTermUpgrade ? "[".concat(component.shortTermUpgrade.name, "](").concat(component.shortTermUpgrade.href, ") (").concat(component.shortTermUpgrade.vulnerabilityCount, " known vulnerabilities)") : '';
    var longTermString = component.longTermUpgrade ? "[".concat(component.longTermUpgrade.name, "](").concat(component.longTermUpgrade.href, ") (").concat(component.longTermUpgrade.vulnerabilityCount, " known vulnerabilities)") : '';
    return "| ".concat(violatedPolicies, " | ").concat(componentInViolation, " | ").concat(componentLicenses, " | ").concat(vulnerabilities, " | ").concat(shortTermString, " | ").concat(longTermString, " |");
}
function createRapidScanReport(blackduck_url, blackduck_api_token, policyViolations, blackduckApiService) {
    var _a;
    return __awaiter(this, void 0, void 0, function () {
        var rapidScanReport, bearerToken, _loop_1, _i, policyViolations_1, policyViolation;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    rapidScanReport = [];
                    if (blackduckApiService === undefined) {
                        blackduckApiService = new blackduck_api_1.BlackduckApiService(blackduck_url, blackduck_api_token);
                    }
                    return [4 /*yield*/, blackduckApiService.getBearerToken()];
                case 1:
                    bearerToken = _b.sent();
                    _loop_1 = function (policyViolation) {
                        var componentIdentifier, componentVersion, upgradeGuidance, vulnerabilities, vulnerabilityResponse, componentVersionOrUndefined, componentReport;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0:
                                    componentIdentifier = policyViolation.componentIdentifier;
                                    return [4 /*yield*/, blackduckApiService.getComponentVersionMatching(bearerToken, componentIdentifier)];
                                case 1:
                                    componentVersion = _c.sent();
                                    upgradeGuidance = undefined;
                                    vulnerabilities = undefined;
                                    if (!(componentVersion !== null)) return [3 /*break*/, 4];
                                    return [4 /*yield*/, blackduckApiService
                                            .getUpgradeGuidanceFor(bearerToken, componentVersion)
                                            .then(function (response) {
                                            if (response.result === null) {
                                                SIGLogger_1.logger.warn("Could not get upgrade guidance for ".concat(componentIdentifier, ": The upgrade guidance result was empty"));
                                                return undefined;
                                            }
                                            return response.result;
                                        })
                                            .catch(function (reason) {
                                            SIGLogger_1.logger.warn("Could not get upgrade guidance for ".concat(componentIdentifier, ": ").concat(reason));
                                            return undefined;
                                        })];
                                case 2:
                                    upgradeGuidance = _c.sent();
                                    return [4 /*yield*/, blackduckApiService.getComponentVulnerabilties(bearerToken, componentVersion)];
                                case 3:
                                    vulnerabilityResponse = _c.sent();
                                    vulnerabilities = (_a = vulnerabilityResponse === null || vulnerabilityResponse === void 0 ? void 0 : vulnerabilityResponse.result) === null || _a === void 0 ? void 0 : _a.items;
                                    _c.label = 4;
                                case 4:
                                    componentVersionOrUndefined = componentVersion === null ? undefined : componentVersion;
                                    componentReport = createComponentReport(policyViolation, componentVersionOrUndefined, upgradeGuidance, vulnerabilities);
                                    rapidScanReport.push(componentReport);
                                    return [2 /*return*/];
                            }
                        });
                    };
                    _i = 0, policyViolations_1 = policyViolations;
                    _b.label = 2;
                case 2:
                    if (!(_i < policyViolations_1.length)) return [3 /*break*/, 5];
                    policyViolation = policyViolations_1[_i];
                    return [5 /*yield**/, _loop_1(policyViolation)];
                case 3:
                    _b.sent();
                    _b.label = 4;
                case 4:
                    _i++;
                    return [3 /*break*/, 2];
                case 5: return [2 /*return*/, rapidScanReport];
            }
        });
    });
}
exports.createRapidScanReport = createRapidScanReport;
function createComponentReport(violation, componentVersion, upgradeGuidance, vulnerabilities) {
    return {
        violatedPolicies: violation.violatingPolicyNames,
        name: "".concat(violation.componentName, " ").concat(violation.versionName),
        href: componentVersion === null || componentVersion === void 0 ? void 0 : componentVersion._meta.href,
        licenses: createComponentLicenseReports(violation.policyViolationLicenses, componentVersion),
        vulnerabilities: createComponentVulnerabilityReports(violation.policyViolationVulnerabilities, vulnerabilities),
        shortTermUpgrade: createUpgradeReport(upgradeGuidance === null || upgradeGuidance === void 0 ? void 0 : upgradeGuidance.shortTerm),
        longTermUpgrade: createUpgradeReport(upgradeGuidance === null || upgradeGuidance === void 0 ? void 0 : upgradeGuidance.longTerm)
    };
}
exports.createComponentReport = createComponentReport;
function createComponentLicenseReports(policyViolatingLicenses, componentVersion) {
    var licenseReport = [];
    if (componentVersion === undefined) {
        licenseReport = policyViolatingLicenses.map(function (license) { return createLicenseReport(license.licenseName, license._meta.href, true); });
    }
    else {
        var violatingPolicyLicenseNames_1 = policyViolatingLicenses.map(function (license) { return license.licenseName; });
        licenseReport = componentVersion.license.licenses.map(function (license) { return createLicenseReport(license.name, license.license, violatingPolicyLicenseNames_1.includes(license.name)); });
    }
    return licenseReport;
}
exports.createComponentLicenseReports = createComponentLicenseReports;
function createComponentVulnerabilityReports(policyViolatingVulnerabilities, componentVulnerabilities) {
    var vulnerabilityReport = [];
    if (componentVulnerabilities === undefined) {
        vulnerabilityReport = policyViolatingVulnerabilities.map(function (vulnerability) { return createVulnerabilityReport(vulnerability.name, true); });
    }
    else {
        var violatingPolicyVulnerabilityNames_1 = policyViolatingVulnerabilities.map(function (vulnerability) { return vulnerability.name; });
        vulnerabilityReport = componentVulnerabilities.map(function (vulnerability) {
            var compVulnBaseScore = vulnerability.useCvss3 ? vulnerability.cvss3.baseScore : vulnerability.cvss2.baseScore;
            return createVulnerabilityReport(vulnerability.name, violatingPolicyVulnerabilityNames_1.includes(vulnerability.name), vulnerability._meta.href, compVulnBaseScore, vulnerability.severity);
        });
    }
    return vulnerabilityReport;
}
exports.createComponentVulnerabilityReports = createComponentVulnerabilityReports;
function createLicenseReport(name, href, violatesPolicy) {
    return {
        name: name,
        href: href,
        violatesPolicy: violatesPolicy
    };
}
exports.createLicenseReport = createLicenseReport;
function createVulnerabilityReport(name, violatesPolicy, href, cvssScore, severity) {
    return {
        name: name,
        violatesPolicy: violatesPolicy,
        href: href,
        cvssScore: cvssScore,
        severity: severity
    };
}
exports.createVulnerabilityReport = createVulnerabilityReport;
function createUpgradeReport(recommendedVersion) {
    if (recommendedVersion === undefined) {
        return undefined;
    }
    return {
        name: recommendedVersion.versionName,
        href: recommendedVersion.version,
        vulnerabilityCount: Object.values(recommendedVersion.vulnerabilityRisk).reduce(function (accumulatedValues, value) { return accumulatedValues + value; }, 0)
    };
}
exports.createUpgradeReport = createUpgradeReport;
